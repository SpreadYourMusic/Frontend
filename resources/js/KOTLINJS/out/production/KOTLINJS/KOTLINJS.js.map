{"version":3,"file":"KOTLINJS.js","sources":["../../../src/apis/ServerAPI.kt","../../../src/test/ServerEmulator.kt","collections/Maps.kt","text/Strings.kt","kotlin/string.kt","collections/Collections.kt","../../../src/apis/ServerAPI2.kt","../../../src/controller/Index.kt","../../../src/Main.kt","../../../src/models/Album.kt","../../../src/models/Playlist.kt","../../../src/models/Song.kt","../../../src/models/User.kt"],"sourcesContent":[null,null,"@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*,*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> = if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/* Not available on platform: JS */\n\n\n\n\n\n\n\n\n\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V>\n        = LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V>\n        = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V>\n        = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty() : Map<K, V> = this ?: emptyMap()\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K) : Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V?\n        = @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean\n        = @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V?\n        = @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K,V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K,V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M\n        = destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when(size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M\n        = destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M\n        = destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M\n        = destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V>\n        = if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V>\n        = if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V>\n        = if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V>\n        = LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V>\n        = LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V>\n        = this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V>\n        = this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V>\n        = this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V>\n        = this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n\n/* Not available on platform: JS */\n\n\n\n\n/* Not available on platform: JS */\n\n\n\n","/*\n * Copyright 2010-2016 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\n\npackage kotlin.text\n\nimport kotlin.comparisons.*\nimport kotlin.internal.contracts.*\n\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        }\n        else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String\n        = (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String\n        = (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String\n        = (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String\n        = (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @returns Returns a string, of length at least [length], consisting of string prepended with [padChar] as many times.\n * as are necessary to reach that length.\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String\n        = (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String\n        = (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence\n        = replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String\n        = (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String\n        = (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String\n        = (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String = regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length)\n            || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n        this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n        this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @returns An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @returns An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n        indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(private val input: CharSequence, private val startIndex: Int, private val limit: Int, private val getNextMatch: CharSequence.(Int) -> Pair<Int, Int>?): Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            }\n            else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                }\n                else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    }\n                    else {\n                        val (index,length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex ->\n        indexOfAny(delimiters, startIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 } })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { startIndex -> findAnyOf(delimitersList, startIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n        rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n        rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","package kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\npublic inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n@kotlin.internal.InlineOnly\npublic inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@Deprecated(\"Use length property instead.\", ReplaceWith(\"length\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline val CharSequence.size: Int get() = length\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n","/*\n * Copyright 2010-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.comparisons.compareValues\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean): Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/* Not available on platform: JS */\n\n\n\n\n\n\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T>\n        = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T>\n        = if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/* Not available on platform: JS */\n\n\n\n\n\n\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/* Not available on platform: JS */\n\n\n\n\n/* Not available on platform: JS */\n\n\n\n\n/* Not available on platform: JS */\n\n\n\n\n\n\n\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T: Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(key: K?, fromIndex: Int = 0, toIndex: Int = size, crossinline selector: (T) -> K?): Int =\n        binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n",null,null,null,null,null,null,null],"names":[],"mappings":"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"}